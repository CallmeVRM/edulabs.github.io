---
layout: default
title: Bandit
parent: Wargames Solutions
nav_order: 81

---

# Bandit

ssh -p 2220 bandit@bandit.labs.overthewire.org

### Level 0 > 1
Connexion : 

```ssh bandit0@bandit.labs.overthewire.org -p 2220```

**Solution** : ```cat readme```

Mot de passe bandit1 : ZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If

### Level 1 > 2

```ssh bandit1@bandit.labs.overthewire.org -p 2220```

Le niveau deux, est un peu tricky, le mot de passe se trouve dans un fichier avec comme nom (-), ce qui fait qu'on ne peut pas utilisÃ© cat, du fait que cette derniÃ¨re attend un paramÃ¨tre aprÃ¨s le dash (-).

Pour rÃ©soudre ce problÃ¨me vous avez plusieurs approches, la premiÃ¨re et la plus rapide, consiste Ã  utiliser la commande ```more```

L'autre solution, c'est l'utilisation de la commande ```cat``` mais en indiquant le chemin absolu
```cat ./-```

**Solution** : ```cat ./-```

Mot de passe bandit2 : 263JGJPfgU6LtdEvgfWU1XP5yac29mFx

### Level 2 > 3

```ssh bandit2@bandit.labs.overthewire.org -p 2220```

Toujours dans la mÃªme la logique que le prÃ©cÃ©dent, sauf que cette fois il y Ã  des espaces qui rajoute une difficultÃ©.

Si vous avez pratiquer un peu de scripting ou de programmation vous connaissez certainement le principe du double quote "" pour contenir un string. Eh bien on va utiliser cette mÃ©thode combiner Ã  un chemin absolu pour rÃ©soudre le challenge.

**Solution** : ```cat ./"--spaces in this filename--"```

Si on veut travailler avec le chemin relatif (valable pour la prÃ©cÃ©dente), on peut utiliser la commande ```cat -- "--spaces in this filename--"``` *On utilise le double dash ```--``` pour indiquier la fin dâ€™options*

Mot de passe bandit3 : MNk8KNH3Usiio41PRUEoDFPqfxLPlSmx


### Level 3 > 4

```ssh bandit3@bandit.labs.overthewire.org -p 2220```

Dans ce challenge, nous avons affaire Ã  un fichier cachÃ© dans le rÃ©pertoire inhere.
Les fichiers cachÃ©s sont plus au moins frÃ©quents sous Linux : tout nom de fichier qui commence par un . (point) nâ€™apparaÃ®t pas dans un simple ls.
On les retrouve par exemple dans les rÃ©pertoires personnels (comme .bashrc, .ssh/, .config/)...


Pour afficher les fichiers cachÃ©s, on utilise la commande ls avec le paramÃ¨tre -a :

- ```-a``` = all files (inclut les fichiers cachÃ©s qui commencent par .)

**Solution** :

```ls -a inhere```

On remarque alors la prÃ©sence dâ€™un fichier cachÃ© nommÃ©  ```...Hiding-From-You```

Il ne reste plus quâ€™Ã  lire son contenu pour obtenir le mot de passe :

```cat inhere/...Hiding-From-You```

Mot de passe bandit4 : 2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ

### Level 4 > 5
```ssh bandit4@bandit.labs.overthewire.org -p 2220```

Le rÃ©pertoire inhere contient plusieurs fichiers aux noms un peu particuliers.
Ils ne sont pas tous du mÃªme type : la majoritÃ© sont des fichiers binaires donc illisibles pour un Ãªtre humain.
Cependant, un seul de ces fichiers est en ASCII text, donc lisible.

Bien sÃ»r, vous pourriez tester manuellement avec :

 ```cat -- inhere/-file00 inhere/-file01 ...``` 
 
Cela fonctionnerait, mais ce serait fastidieux. Le but ici est justement de dÃ©couvrir et dâ€™utiliser de nouvelles commandes qui facilitent la vie.

**Solution** :

Pour rÃ©soudre ce challenge, on procÃ¨de en deux Ã©tapes :

Identifier le fichier lisible par un humain avec :
```file ./inhere/*```

On remarque alors la prÃ©sence dâ€™un fichier de type ```ASCII text```, et il ne reste plus quâ€™Ã  lire son contenu pour obtenir le mot de passe :

```cat -- ./inhere/-file07```

Mot de passe bandit5 : 4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw

### Level 5 > 6
```ssh bandit5@bandit.labs.overthewire.org -p 2220```

Le mot de passe du prochain niveau est cachÃ© quelque part dans le rÃ©pertoire inhere, et pour ne pas nous faciliter la tÃ¢che il y a une vingtaine de rÃ©pertoires, et chacun peut potentiellement abriter le fichier recherchÃ©.

Ce fameux fichier Ã  trouver possÃ¨de les caractÃ©ristiques suivantes :
- Il est lisible par un humain.
- Sa taille est exactement 1033 octets.
- Il nâ€™est pas exÃ©cutable.

Vous avez envie de parcourir chaque dossier, ouvrir chaque fichier et vÃ©rifier manuellement ?
Avant de perdre au moins une heure de votre vie, essayez plutÃ´t la commande :
```ls -lR inhere```

Vous rÃ©aliserez alors lâ€™ampleur de la tÃ¢che... et pourquoi il faut absolument simplifier la recherche.


**Solution** :

Dans ce type de scÃ©nario, la commande find est votre meilleure alliÃ©e.
Elle permet de combiner plusieurs critÃ¨res (type, taille, permissionsâ€¦) pour cibler trÃ¨s rapidement le bon fichier selon les critÃ¨res qu'on possÃ¨de.
Voici la commande magique :

```find inhere -type f -size 1033c ! -executable```

**DÃ©composition**

- ```find inhere``` : parcourt rÃ©cursivement tout le rÃ©pertoire inhere.

- ```-type f``` : premier filtre â†’ on ne garde que les fichiers (pas les rÃ©pertoires).

- ```-size 1033c``` : second filtre â†’ on ne garde que les fichiers dont la taille est exactement 1033 octets (c = bytes).

- ```! -executable``` : troisiÃ¨me filtre â†’ on exclut tous les fichiers exÃ©cutables.

Une fois le fichier trouvÃ© on exÃ©cute la commande : 

```cat inhere/maybehere07/.file2```

Mot de passe bandit6 : HWasnPhtq9AVKe0dmk45nxy20cvUa6EG

**## Level 6 > 7**

```ssh bandit6@bandit.labs.overthewire.org -p 2220```

Le mot de passe du prochain niveau nâ€™est pas dans un dossier bien identifiÃ© cette fois-ci : il est cachÃ© quelque part sur tout le serveur.
Et pour corser lâ€™affaire, le fichier Ã  trouver nâ€™est pas unique par son nom, mais par ses propriÃ©tÃ©s :

- Il est possÃ©dÃ© par lâ€™utilisateur bandit7.
- Il est possÃ©dÃ© par le groupe bandit6.
- Sa taille est exactement 33 octets.

Autrement dit, si vous comptez fouiller chaque rÃ©pertoire Ã  la main avec ls, vous n'avez pas fini ta soirÃ©e. Il faut donc une mÃ©thode rapide et intelligente.

### Solution

On va rÃ©utiliser la commande ```find```, mais cette fois ci on va la combiner avec d'autres conditions (taille, propiÃ©taire, groupe,...)

```find / -user bandit7 -group bandit6 -size 33c 2>/dev/null```

**DÃ©composition**

- ```find /``` : lance la recherche Ã  partir de la racine /, donc sur tout le systÃ¨me.

- ```-user bandit7``` : filtre â†’ fichiers appartenant Ã  lâ€™utilisateur bandit7.

- ```-group bandit6``` : filtre â†’ fichiers appartenant au groupe bandit6.

- ```-size 33c``` : filtre â†’ fichiers dont la taille est exactement 33 octets (c = bytes).

- ```2>/dev/null``` : redirige les erreurs (permissions refusÃ©es) vers /dev/null pour ne pas polluer lâ€™affichage, elle affichera uniquement si le fichier est trouvÃ©.

Une fois le fichier identifiÃ©, il suffit de lire son contenu avec cat :

```cat /var/lib/dpkg/info/bandit7.password```

Mot de passe bandit7 : morbNTDkSW6jIlUc0ymOdMaLnOlFVAaj


**## Level 7 > 8**

```ssh bandit7@bandit.labs.overthewire.org -p 2220```

Cette fois, pas besoin de fouiller tout le serveur, le challenge nous dit simplement :

ğŸ‘‰ Le mot de passe du prochain niveau est stockÃ© dans le fichier ```data.txt```, juste Ã  cÃ´tÃ© du mot ```millionth```.

Autrement dit, quelque part dans le fichier ```data.txt```, une ligne contient ce mot-clÃ© et juste aprÃ¨s le mot ```millionth``` se trouve le prÃ©cieux sÃ©same.

### Solution

Ici, pas besoin de rÃ©inventer la roue. La commande grep est parfaite pour rechercher un mot prÃ©cis dans un fichier.

```grep millionth .data.txt```

Mot de passe bandit8 : dfwvzFQi4mU0wfNbFOe9RoWskMLg7eEc

## Level 8 > 9

Cette fois, le challenge est un peu plus subtil.
Le mot de passe du prochain niveau est cachÃ© dans le fichier data.txtâ€¦ mais il nâ€™est pas marquÃ© par un mot-clÃ© particulier.

La consigne dit simplement :

Le mot de passe est la seule ligne du fichier qui apparaÃ®t une seule fois.
Toutes les autres lignes apparaissent plusieurs fois.

On doit donc :

1. Trier le fichier (pour que les doublons soient regroupÃ©s).
2. Identifier la ligne unique (qui apparaÃ®t une seule fois).

### Solution

Câ€™est typiquement un cas oÃ¹ ```sort``` et ```uniq``` font le job, et on peut enchaÃ®ner les commandes grÃ¢ce aux pipes (|) :

```sort data.txt | uniq -u```

- ```sort data.txt``` â†’ trie les lignes du fichier par ordre alphabÃ©tique, ce qui regroupe les doublons.

- ```uniq -u``` â†’ affiche uniquement les lignes uniques (celles qui apparaissent une seule fois).

RÃ©sultat : on obtient directement la ligne contenant le mot de passe.

Mot de passe bandit9 : 4CKMh1JI91bUIZZPXDqGanal4xvAg0JM

## Level 9 > 10

Dans ce challenge, le mot de passe est cachÃ© dans le fichier ```data.txt```, mais ce fichier contient surtout des donnÃ©es illisibles Ã  l'humain.

Les seules indication donnÃ©e :

- Le mot de passe est dans une des rares chaÃ®nes lisibles par un humain.
- Cette chaÃ®ne est prÃ©cÃ©dÃ©e par plusieurs caractÃ¨res ```=```.

Donc, notre stratÃ©gie va Ãªtre de filtrer uniquement ce qui est lisible et de chercher les ```=``` pour repÃ©rer la bonne ligne.


### Solution

Bien sÃ»r, on est automatiquement tentÃ© de lancer un ```cat data.txt``` ! Mais non, trop simple sinon ! Et surtout, la commande nous renvoie un tas de caractÃ¨res illisibles : du charabia incomprÃ©hensible pour un humain.

La commande idÃ©ale ici est ```strings```, qui extrait toutes les sÃ©quences lisibles (ASCII) dâ€™un fichier binaire.

Ensuite, on peut chaÃ®ner sa sortie avec la commande ```grep``` en utilisant un pipe (|), pour ne garder que les lignes contenant le caractÃ¨re ```=``` en plusieurs fois.

```strings data.txt | grep "==="```

Mot de passe bandit10 : FGUW5ilLVJrxX9kMYMmlN4MgbpfMiqey


## Level 10 > 11

Le challenge nous dit que le mot de passe du prochain niveau est stockÃ© dans le fichier ```data.txt```, mais cette fois-ci il ne sâ€™agit pas de texte en clair ni de binaire incomprÃ©hensible.

ğŸ‘‰ Le contenu du fichier est encodÃ© en ```Base64```, qui est un systÃ¨me dâ€™encodage qui transforme des donnÃ©es binaires en caractÃ¨res lisibles

### Solution

La commande adaptÃ©e est base64, avec lâ€™option ```-d``` (decode), qui permet de dÃ©coder une chaÃ®ne Base64 vers son contenu original.

```base64 -d data.txt```

Mot de passe bandit11 : dtR173fZKb0RRsDFSGsg2RWnpNVj3qRr

## Level 11 > 12

Cette fois, le mot de passe est cachÃ© dans le fichier data.txt, mais il nâ€™est pas en clair ni en Base64.

ğŸ‘‰ Le contenu a Ã©tÃ© transformÃ© avec un chiffrement trÃ¨s simple : ROT13.

ROT13 est une forme trÃ¨s basique de chiffrement par substitution. dzChaque lettre est remplacÃ©e par celle qui se trouve 13 positions plus loin dans lâ€™alphabet.

### Solution

Pour dÃ©coder ROT13 sous Linux, on peut utiliser la commande tr (translate), qui permet de remplacer des ensembles de caractÃ¨res par dâ€™autres.

```cat data.txt | tr 'A-Za-z' 'N-ZA-Mn-za-m'```

- ```cat data.txt``` â†’ affiche le contenu du fichier.

- ```|``` â†’ envoie ce contenu Ã  la commande suivante.

- ```tr 'A-Za-z' 'N-ZA-Mn-za-m'``` â†’ traduit chaque lettre majuscule et minuscule en la dÃ©calant de 13 positions.

Mot de passe bandit12 : 7x16WNeHIi5YkIhWsfFIqoognUTyj9Q4

## Level 12 > 13

Dans ce challenge, le mot de passe est stockÃ© dans le fichier data.txt.
Mais attention, il ne sâ€™agit pas dâ€™un texte encodÃ© comme en Base64 ou ROT13.

ğŸ‘‰ Cette fois, data.txt est un hexdump dâ€™un fichier qui a Ã©tÃ© compressÃ© plusieurs fois (gzip, bzip2, tar, etc.). Il va donc falloir :

- Reconstituer le fichier original Ã  partir de son hexdump.
- DÃ©compresser Ã©tape par Ã©tape jusquâ€™Ã  retrouver le fichier final qui contient le mot de passe.

### Solution

Comme on ne sait pas ce qui se trouve dans le fichier ```data.txt``` on va opter pour un travail propre dans le dossier /tmp a fin d'Ã©viter de polluer l'environnement du serveur.

```mktemp -d```

Il nous retournera un dossier du type : ```/tmp/tmp.AvSiTzLTY8``` son nom peut Ãªtre diffÃ©rent chez vous

```cd /tmp/tmp.AvSiTzLTY8```

Copier le fichier data.txt dans ce dossier :

```cp ~/data.txt .```

Convertir le hexdump en fichier binaire avec xxd -r :

```xxd -r data.txt > data.hex```

Identifier le type du fichier avec file, puis le dÃ©compresser avec lâ€™outil appropriÃ© (gzip, bzip2, tar, etc.) :

```file data.bin```

On remarque que notre fichier ```data.bin``` est un fichier compressÃ© avec gzip, on va le renommer :

```mv data.bin data.gz```

Et le dÃ©compresser avec la commande :

```gunzip data.gz```

On vÃ©rifie le type de notre nouveau fichier :
```file data```dddddddddddddd


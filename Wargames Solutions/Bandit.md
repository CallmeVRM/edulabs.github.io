---
layout: default
title: Bandit
parent: Wargames Solutions
nav_order: 81

---

# Bandit

ssh -p 2220 bandit@bandit.labs.overthewire.org

### Level 0 > 1
Connexion : 

```ssh bandit0@bandit.labs.overthewire.org -p 2220```

**Solution** : ```cat readme```

Mot de passe bandit1 : ZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If

### Level 1 > 2

```ssh bandit1@bandit.labs.overthewire.org -p 2220```

Le niveau deux, est un peu tricky, le mot de passe se trouve dans un fichier avec comme nom (-), ce qui fait qu'on ne peut pas utilisÃ© cat, du fait que cette derniÃ¨re attend un paramÃ¨tre aprÃ¨s le dash (-).

Pour rÃ©soudre ce problÃ¨me vous avez plusieurs approches, la premiÃ¨re et la plus rapide, consiste Ã  utiliser la commande ```more```

L'autre solution, c'est l'utilisation de la commande ```cat``` mais en indiquant le chemin absolu
```cat ./-```

**Solution** : ```cat ./-```

Mot de passe bandit2 : 263JGJPfgU6LtdEvgfWU1XP5yac29mFx

### Level 2 > 3

```ssh bandit2@bandit.labs.overthewire.org -p 2220```

Toujours dans la mÃªme la logique que le prÃ©cÃ©dent, sauf que cette fois il y Ã  des espaces qui rajoute une difficultÃ©.

Si vous avez pratiquer un peu de scripting ou de programmation vous connaissez certainement le principe du double quote "" pour contenir un string. Eh bien on va utiliser cette mÃ©thode combiner Ã  un chemin absolu pour rÃ©soudre le challenge.

**Solution** : ```cat ./"--spaces in this filename--"```

Si on veut travailler avec le chemin relatif (valable pour la prÃ©cÃ©dente), on peut utiliser la commande ```cat -- "--spaces in this filename--"``` *On utilise le double dash ```--``` pour indiquier la fin dâ€™options*

Mot de passe bandit3 : MNk8KNH3Usiio41PRUEoDFPqfxLPlSmx


### Level 3 > 4

```ssh bandit3@bandit.labs.overthewire.org -p 2220```

Dans ce challenge, nous avons affaire Ã  un fichier cachÃ© dans le rÃ©pertoire inhere.
Les fichiers cachÃ©s sont plus au moins frÃ©quents sous Linux : tout nom de fichier qui commence par un . (point) nâ€™apparaÃ®t pas dans un simple ls.
On les retrouve par exemple dans les rÃ©pertoires personnels (comme .bashrc, .ssh/, .config/)...


Pour afficher les fichiers cachÃ©s, on utilise la commande ls avec le paramÃ¨tre -a :

- ```-a``` = all files (inclut les fichiers cachÃ©s qui commencent par .)

**Solution** :

```ls -a inhere```

On remarque alors la prÃ©sence dâ€™un fichier cachÃ© nommÃ©  ```...Hiding-From-You```

Il ne reste plus quâ€™Ã  lire son contenu pour obtenir le mot de passe :

```cat inhere/...Hiding-From-You```

Mot de passe bandit4 : 2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ

### Level 4 > 5
```ssh bandit4@bandit.labs.overthewire.org -p 2220```

Le rÃ©pertoire inhere contient plusieurs fichiers aux noms un peu particuliers.
Ils ne sont pas tous du mÃªme type : la majoritÃ© sont des fichiers binaires donc illisibles pour un Ãªtre humain.
Cependant, un seul de ces fichiers est en ASCII text, donc lisible.

Bien sÃ»r, vous pourriez tester manuellement avec :

 ```cat -- inhere/-file00 inhere/-file01 ...``` 
 
Cela fonctionnerait, mais ce serait fastidieux. Le but ici est justement de dÃ©couvrir et dâ€™utiliser de nouvelles commandes qui facilitent la vie.

**Solution** :

Pour rÃ©soudre ce challenge, on procÃ¨de en deux Ã©tapes :

Identifier le fichier lisible par un humain avec :
```file ./inhere/*```

On remarque alors la prÃ©sence dâ€™un fichier de type ```ASCII text```, et il ne reste plus quâ€™Ã  lire son contenu pour obtenir le mot de passe :

```cat -- ./inhere/-file07```

Mot de passe bandit5 : 4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw

### Level 5 > 6
```ssh bandit5@bandit.labs.overthewire.org -p 2220```

Le mot de passe du prochain niveau est cachÃ© quelque part dans le rÃ©pertoire inhere, et pour ne pas nous faciliter la tÃ¢che il y a une vingtaine de rÃ©pertoires, et chacun peut potentiellement abriter le fichier recherchÃ©.

Ce fameux fichier Ã  trouver possÃ¨de les caractÃ©ristiques suivantes :
- Il est lisible par un humain.
- Sa taille est exactement 1033 octets.
- Il nâ€™est pas exÃ©cutable.

Vous avez envie de parcourir chaque dossier, ouvrir chaque fichier et vÃ©rifier manuellement ?
Avant de perdre au moins une heure de votre vie, essayez plutÃ´t la commande :
```ls -lR inhere```

Vous rÃ©aliserez alors lâ€™ampleur de la tÃ¢che... et pourquoi il faut absolument simplifier la recherche.


**Solution** :

Dans ce type de scÃ©nario, la commande find est votre meilleure alliÃ©e.
Elle permet de combiner plusieurs critÃ¨res (type, taille, permissionsâ€¦) pour cibler trÃ¨s rapidement le bon fichier selon les critÃ¨res qu'on possÃ¨de.
Voici la commande magique :

```find inhere -type f -size 1033c ! -executable```

**DÃ©composition**

- ```find inhere``` : parcourt rÃ©cursivement tout le rÃ©pertoire inhere.

- ```-type f``` : premier filtre â†’ on ne garde que les fichiers (pas les rÃ©pertoires).

- ```-size 1033c``` : second filtre â†’ on ne garde que les fichiers dont la taille est exactement 1033 octets (c = bytes).

- ```! -executable``` : troisiÃ¨me filtre â†’ on exclut tous les fichiers exÃ©cutables.

Une fois le fichier trouvÃ© on exÃ©cute la commande : 

```cat inhere/maybehere07/.file2```

Mot de passe bandit6 : HWasnPhtq9AVKe0dmk45nxy20cvUa6EG

**## Level 6 > 7**

```ssh bandit6@bandit.labs.overthewire.org -p 2220```

Le mot de passe du prochain niveau nâ€™est pas dans un dossier bien identifiÃ© cette fois-ci : il est cachÃ© quelque part sur tout le serveur.
Et pour corser lâ€™affaire, le fichier Ã  trouver nâ€™est pas unique par son nom, mais par ses propriÃ©tÃ©s :

- Il est possÃ©dÃ© par lâ€™utilisateur bandit7.
- Il est possÃ©dÃ© par le groupe bandit6.
- Sa taille est exactement 33 octets.

Autrement dit, si vous comptez fouiller chaque rÃ©pertoire Ã  la main avec ls, vous n'avez pas fini ta soirÃ©e. Il faut donc une mÃ©thode rapide et intelligente.

### Solution

On va rÃ©utiliser la commande ```find```, mais cette fois ci on va la combiner avec d'autres conditions (taille, propiÃ©taire, groupe,...)

```find / -user bandit7 -group bandit6 -size 33c 2>/dev/null```

**DÃ©composition**

- ```find /``` : lance la recherche Ã  partir de la racine /, donc sur tout le systÃ¨me.

- ```-user bandit7``` : filtre â†’ fichiers appartenant Ã  lâ€™utilisateur bandit7.

- ```-group bandit6``` : filtre â†’ fichiers appartenant au groupe bandit6.

- ```-size 33c``` : filtre â†’ fichiers dont la taille est exactement 33 octets (c = bytes).

- ```2>/dev/null``` : redirige les erreurs (permissions refusÃ©es) vers /dev/null pour ne pas polluer lâ€™affichage, elle affichera uniquement si le fichier est trouvÃ©.

Une fois le fichier identifiÃ©, il suffit de lire son contenu avec cat :

```cat /var/lib/dpkg/info/bandit7.password```

Mot de passe bandit7 : morbNTDkSW6jIlUc0ymOdMaLnOlFVAaj


**## Level 7 > 8**

```ssh bandit7@bandit.labs.overthewire.org -p 2220```

Cette fois, pas besoin de fouiller tout le serveur, le challenge nous dit simplement :

ğŸ‘‰ Le mot de passe du prochain niveau est stockÃ© dans le fichier ```data.txt```, juste Ã  cÃ´tÃ© du mot ```millionth```.

Autrement dit, quelque part dans le fichier ```data.txt```, une ligne contient ce mot-clÃ© et juste aprÃ¨s le mot ```millionth``` se trouve le prÃ©cieux sÃ©same.

### Solution

Ici, pas besoin de rÃ©inventer la roue. La commande grep est parfaite pour rechercher un mot prÃ©cis dans un fichier.

```grep millionth .data.txt```

Mot de passe bandit8 : dfwvzFQi4mU0wfNbFOe9RoWskMLg7eEc

## Level 8 > 9

Cette fois, le challenge est un peu plus subtil.
Le mot de passe du prochain niveau est cachÃ© dans le fichier data.txtâ€¦ mais il nâ€™est pas marquÃ© par un mot-clÃ© particulier.

La consigne dit simplement :

Le mot de passe est la seule ligne du fichier qui apparaÃ®t une seule fois.
Toutes les autres lignes apparaissent plusieurs fois.

On doit donc :

1. Trier le fichier (pour que les doublons soient regroupÃ©s).
2. Identifier la ligne unique (qui apparaÃ®t une seule fois).

### Solution

Câ€™est typiquement un cas oÃ¹ ```sort``` et ```uniq``` font le job, et on peut enchaÃ®ner les commandes grÃ¢ce aux pipes (|) :

```sort data.txt | uniq -u```

- ```sort data.txt``` â†’ trie les lignes du fichier par ordre alphabÃ©tique, ce qui regroupe les doublons.

- ```uniq -u``` â†’ affiche uniquement les lignes uniques (celles qui apparaissent une seule fois).

RÃ©sultat : on obtient directement la ligne contenant le mot de passe.

Mot de passe bandit9 : 4CKMh1JI91bUIZZPXDqGanal4xvAg0JM

## Level 9 > 10

Dans ce challenge, le mot de passe est cachÃ© dans le fichier ```data.txt```, mais ce fichier contient surtout des donnÃ©es illisibles Ã  l'humain.

Les seules indication donnÃ©e :

- Le mot de passe est dans une des rares chaÃ®nes lisibles par un humain.
- Cette chaÃ®ne est prÃ©cÃ©dÃ©e par plusieurs caractÃ¨res ```=```.

Donc, notre stratÃ©gie va Ãªtre de filtrer uniquement ce qui est lisible et de chercher les ```=``` pour repÃ©rer la bonne ligne.


### Solution

Bien sÃ»r, on est automatiquement tentÃ© de lancer un ```cat data.txt``` ! Mais non, trop simple sinon ! Et surtout, la commande nous renvoie un tas de caractÃ¨res illisibles : du charabia incomprÃ©hensible pour un humain.

La commande idÃ©ale ici est ```strings```, qui extrait toutes les sÃ©quences lisibles (ASCII) dâ€™un fichier binaire.

Ensuite, on peut chaÃ®ner sa sortie avec la commande ```grep``` en utilisant un pipe (|), pour ne garder que les lignes contenant le caractÃ¨re ```=``` en plusieurs fois.

```strings data.txt | grep "==="```

Mot de passe bandit10 : FGUW5ilLVJrxX9kMYMmlN4MgbpfMiqey


## Level 10 > 11

Le challenge nous dit que le mot de passe du prochain niveau est stockÃ© dans le fichier ```data.txt```, mais cette fois-ci il ne sâ€™agit pas de texte en clair ni de binaire incomprÃ©hensible.

ğŸ‘‰ Le contenu du fichier est encodÃ© en ```Base64```, qui est un systÃ¨me dâ€™encodage qui transforme des donnÃ©es binaires en caractÃ¨res lisibles

### Solution

La commande adaptÃ©e est base64, avec lâ€™option ```-d``` (decode), qui permet de dÃ©coder une chaÃ®ne Base64 vers son contenu original.

```base64 -d data.txt```

Mot de passe bandit11 : dtR173fZKb0RRsDFSGsg2RWnpNVj3qRr

## Level 11 > 12

Cette fois, le mot de passe est cachÃ© dans le fichier data.txt, mais il nâ€™est pas en clair ni en Base64.

ğŸ‘‰ Le contenu a Ã©tÃ© transformÃ© avec un chiffrement trÃ¨s simple : ROT13.

ROT13 est une forme trÃ¨s basique de chiffrement par substitution. dzChaque lettre est remplacÃ©e par celle qui se trouve 13 positions plus loin dans lâ€™alphabet.

### Solution

Pour dÃ©coder ROT13 sous Linux, on peut utiliser la commande tr (translate), qui permet de remplacer des ensembles de caractÃ¨res par dâ€™autres.

```cat data.txt | tr 'A-Za-z' 'N-ZA-Mn-za-m'```

- ```cat data.txt``` â†’ affiche le contenu du fichier.

- ```|``` â†’ envoie ce contenu Ã  la commande suivante.

- ```tr 'A-Za-z' 'N-ZA-Mn-za-m'``` â†’ traduit chaque lettre majuscule et minuscule en la dÃ©calant de 13 positions.

Mot de passe bandit12 : 7x16WNeHIi5YkIhWsfFIqoognUTyj9Q4

## Level 12 > 13

Dans ce challenge, le mot de passe est stockÃ© dans le fichier data.txt.
Mais attention, il ne sâ€™agit pas dâ€™un texte encodÃ© comme en Base64 ou ROT13.

ğŸ‘‰ Cette fois, data.txt est un hexdump dâ€™un fichier qui a Ã©tÃ© compressÃ© plusieurs fois (gzip, bzip2, tar, etc.). Il va donc falloir :

- Reconstituer le fichier original Ã  partir de son hexdump.
- DÃ©compresser Ã©tape par Ã©tape jusquâ€™Ã  retrouver le fichier final qui contient le mot de passe.

### Solution

Comme on ne sait pas ce qui se trouve dans le fichier ```data.txt``` on va opter pour un travail propre dans le dossier /tmp a fin d'Ã©viter de polluer l'environnement du serveur.

```mktemp -d```

Il nous retournera un dossier du type : ```/tmp/tmp.AvSiTzLTY8``` son nom peut Ãªtre diffÃ©rent chez vous

```cd /tmp/tmp.AvSiTzLTY8```

Copier le fichier data.txt dans ce dossier :

```cp ~/data.txt .```

Convertir le hexdump en fichier binaire avec xxd -r :

```xxd -r data.txt > data.hex```

Identifier le type du fichier avec file, puis le dÃ©compresser avec lâ€™outil appropriÃ© (gzip, bzip2, tar, etc.) :

```file data.bin```

On remarque que notre fichier ```data.bin``` est un fichier compressÃ© avec gzip, on va le renommer :
```mv data.bin data.gz```

Et le dÃ©compresser avec la commande :
```gunzip data.gz```

On vÃ©rifie de nouveau le type de notre fichier qu'on vient d'Ã©xtraire :
```file data```

Notre nouveau fichier est un ```bzip2```, alors on va le renommer : ```mv data data.bz2```

Et on va le dÃ©compresser : ```bunzip2 data.bz2```

Et continue de rÃ©pÃ©ter la procÃ©dure, avec le nouveau fichier ```data``` jusqu'Ã  obtenir le fichier contenant le mot de passe.

1. On vÃ©rifie le type : ```file data```
2. On renomme pour avoir la bonne extension : ```mv data.bin data.gz```
3. On dÃ©compresse

Je ne citerais pas toute la procÃ©dure car cela change avec le temps.

Pour ma part je l'ai obtenu dans le ```data8``` en faisant un ```cat data8```

![alt text](image.png)

Mot de passe de bandit13 : FO5dwFsc0cbaIiH0h8J2eUks2vdTDwAn


## Level 13 > 14

Le mot de passe du prochain niveau est stockÃ© dans ```/etc/bandit_pass/bandit14```

ğŸ‘‰ ProblÃ¨me : ce fichier ne peut Ãªtre lu que par lâ€™utilisateur ```bandit14```

Donc, mÃªme connectÃ© en tant que bandit13, on ne peut pas simplement faire : ```cat /etc/bandit_pass/bandit14``` ni on peut changer les permissions.

Cependant, au lieu dâ€™un mot de passe, ce niveau nous fournit une clÃ© privÃ©e SSH dans le fichier :

```sshkey.private```

Avec cette clÃ© (disponible dans le home de bandit13), on peut directement se connecter en tant que bandit14, sans connaÃ®tre son mot de passe.

### Solution

```ssh -i sshkey.private bandit14@localhost -p 2220```

- ```-i sshkey.private``` â†’ indique quelle clÃ© privÃ©e utiliser.

VoilÃ  maintenant qu'on est sur la machine bandit14, on rÃ©cupÃ¨re le mot de passe dans le fichier ```/etc/bandit_pass/bandit14``` qui nous servira pour le prochain challenge


Mot de passe de bandit14 : MU4VWeTyJk8ROof1qqmcBPaLh7lDCPvS

## Level 14 > 15

Aussi surprenant que cela puisse paraitre, le mot de passe du prochain niveau nâ€™est pas cachÃ© dans un fichier.

ğŸ‘‰ Cette fois, il faut soumettre le mot de passe actuel au port 30000 en local (localhost).

En dâ€™autres termes :
- On connaÃ®t le mot de passe de bandit14 (trouvÃ© au niveau prÃ©cÃ©dent).
- On doit lâ€™envoyer sur le port TCP 30000 du serveur local.
- Le serveur nous retournera en Ã©change le mot de passe de bandit15

Pour tester des communications simples avec un port TCP, on a plusieurs outils :

- ```telnet``` : ancien mais pratique.
- ```nc (netcat)``` : couteau suisse rÃ©seau.
- ```openssl s_client``` : utile pour du SSL/TLS (pas nÃ©cessaire ici).

Ici, comme câ€™est une connexion simple en clair, nc est parfait

```nc localhost 30000```

Une fois la connexion Ã©tablie, on prompt le mot de passe de ```bandit14```.


Mot de passe de bandit15 : 8xCjnmgoKbGLhHFAZlGE5Tmu4M2tKJQo

## Level 15 > 16
Dans ce challenge, on doit rÃ©cupÃ©rer le mot de passe du prochain niveau, mais cette fois-ci la communication se fait via SSL/TLS.

La consigne :

- Se connecter au port 30001 sur localhost.
- Envoyer le mot de passe actuel (bandit15).
- Le serveur rÃ©pondra avec le mot de passe du prochain niveau (bandit16).

DiffÃ©rence avec le niveau prÃ©cÃ©dent : il ne sâ€™agit pas dâ€™une connexion simple en TCP (nc), mais dâ€™une communication chiffrÃ©e en SSL/TLS.

### Solution
Pour ce genre de connexion, lâ€™outil idÃ©al est :

```openssl s_client``` â†’ permet dâ€™initier une connexion SSL/TLS Ã  un serveur, un peu comme nc mais sÃ©curisÃ©.

```openssl s_client -connect localhost:30001```

Une fois connectÃ©, tapez ou collez le mot de passe actuel ```bandit15``` et appuyer sur EntrÃ©e. VoilÃ  le serveur renvoie alors le mot de passe du prochain niveau (bandit16)

Mot de passe de bandit16 : kSkvUpMQ7lBYyCM4GBPvCvT1BfWRy0Dx



## Level 16 > 17

Cette fois, le challenge prend une tournure plus rÃ©aliste cÃ´tÃ© sÃ©curitÃ© rÃ©seau.

Le mot de passe de ```bandit16``` doit Ãªtre envoyÃ© Ã  un port entre ```31000``` et ```32000``` sur ```localhost```.
Mais il nâ€™y a pas quâ€™un seul port ouvert dans cette plage !

Il faut donc :

- Scanner pour trouver les ports ouverts.
- VÃ©rifier lesquels parlent en SSL/TLS.
- Tester avec le mot de passe actuel.

Un seul port donnera la clÃ© ssh privÃ©e de bandit17.

### Solution

Pour rÃ©soudre ce problÃ¨me il faut commencer par scanner les ports dans la plage 31000-32000, Ã  fin de trouver un port qui pourrait nous intÃ©resser :

```nmap -sV -p31000-32000 localhost```

Selon le rÃ©sultat (les ports ouverts), on testera avec la commande ```openssl s_client``` et le port adÃ©quat

![alt text](image-1.png)

Dans le rÃ©sultat du scan on Ã  un port qui pourrait potentiellement nous intÃ©resser, c'est le 31790, car 31518 est en mode echo.

Alors on va faire une demande de connexion vers ce port. Le -quiet est important pour Ã©viter un KEYUPDATE

```openssl s_client -connect localhost:31790 -quiet```

On rentre le mot de passe et on obtient la clÃ© privÃ© de bandit17.

Qu'on va copiÃ© et coller dans un fichier temporaire :

```
cd $(mktemp -d)
nano bandit17
```

On colle la clÃ©, on sauvegarde et on quitte.

On ajuste les permissions.

```chmod 600 bandit17```

Et finalement on se connecte :

```ssh -i /tmp/tmp.0ISzvsPr1W/bandit17 bandit17@localhost -p 2220```

*PS: Pour changer les droits de la clÃ© privÃ©e sur Windows :* 
```
icacls .\id_rsa /inheritance:r
icacls .\id_rsa /grant:r "$($env:USERNAME):(R)"
```

---

## Level 17 > 18

Dans ce challenge, il y a deux fichiers dans le home directory :

- passwords.old
- passwords.new

ğŸ‘‰ Le mot de passe du prochain niveau est dans passwords.new. Câ€™est la seule ligne qui a changÃ© par rapport Ã  passwords.old, et biensur on ne va pas le faire Ã  la mano.

Pour comparer deux fichiers et voir leurs diffÃ©rences, la commande idÃ©ale est ```diff```.
Elle affiche ligne par ligne ce qui a Ã©tÃ© modifiÃ©, ajoutÃ© ou supprimÃ©.

### Solution

Comparer les deux fichiers :
```diff passwords.old passwords.new```

La sortie va montrer uniquement la ligne qui diffÃ¨re entre les deux fichiers, le premier concerne password.old et le deuxiÃ¨me passwords.new, ce qui nous intÃ©resse c'est la deuxiÃ¨me ligne qui correspond au mot de passe de bandit18.

Mot de passe de bandit18 : x2gLTTjFwMOhQ8oWNbMN362QKxfRqGlO

## Level 18 > 19

Dans ce challenge, le mot de passe du prochain niveau est stockÃ© dans un fichier readme dans notre home directory.

Mais il y a un piÃ¨ge : .bashrc a Ã©tÃ© modifiÃ© pour nous dÃ©connecter immÃ©diatement dÃ¨s que lâ€™on ouvre une session SSH.

On doit contourner cette contrainte en Ã©vitant dâ€™ouvrir un shell interactif.
Et il se trouve que SSH nous permet dâ€™exÃ©cuter directement une commande distante sans lancer de session normale.

Donc au lieu de se connecter puis taper la commande, on va envoyer la commande directement dans la ligne SSH.

### Solution
```ssh bandit18@bandit.labs.overthewire.org -p 2220 cat readme```

Mot de passe de bandit19 : cGWpMaKXVwDUNgPAVJbWYuGHVn9zl3j8

## Level 19 > 20

Selon les donnÃ©es fourni, pour ce niveau on doit utiliser un binaire spÃ©cial situÃ© dans notre home directory sous le nom de : ```bandit20-do``` pour rÃ©cupÃ©rer le mot de passe qui se trouve dans ```/etc/bandit_pass```

Ce rÃ©pertoire ```/etc/bandit_pass``` contient plusieurs fichiers, et chaque fichier ne peut Ãªtre lu que par son propriÃ©taire, dans notre cas le fichier ```bandit20``` et c'est lÃ  ou se trouve le mot de passe.

Vous pouvez essayer de faire un ```cat /etc/bandit_pass/bandit20``` vous obtiendrez un refus d'accÃ¨s.

Le binaire ```bandit20-do``` a un comportement particulier : il a le bit setuid d'activÃ©, câ€™est-Ã -dire quâ€™il sâ€™exÃ©cute avec les privilÃ¨ges de son propriÃ©taire (ici bandit20).

on peut faire un check avec la commande :
```ls -l bandit20-do``` 

On voit bien le ```s``` dans les permissions ```-rwsr-x---``` qui nous indique que le bit est bien prÃ©sent ```-rwsr-x--- 1 bandit20 bandit19 14884 Aug 15 13:16 bandit20-do```

On peut aussi faire un check avec la commande : ```file bandit20-do``` 

C'est une fonctionnalitÃ© souvent utilisÃ©e pour permettre Ã  des utilisateurs non privilÃ©giÃ©s d'exÃ©cuter des programmes qui ont besoin de droits Ã©levÃ©s (comme la commande passwd qui doit Ã©crire dans /etc/shadow).

En clair : mÃªme si on est connectÃ© en bandit19, quand on exÃ©cute ce binaire, il agit comme si on Ã©tait bandit20.

Lorsqu'on l'exÃ©cute il nous donne une petite astuce :

![alt text](image-2.png)

Câ€™est donc la clÃ© pour accÃ©der au mot de passe qui se trouve, dans ```/etc/bandit_pass```.

### Solution

On va donc utilisÃ© notre binaire ```bandit20-do``` pour ouvrir le fichier ```/etc/bandit_pass/bandit20```

```./bandit20-do cat /etc/bandit_pass/bandit20```

**Attention**

L'utilisation du setuid peut Ãªtre dangereuse si elle est mal gÃ©rÃ©e :
Un programme setuid mal sÃ©curisÃ© peut Ãªtre exploitÃ© pour obtenir des privilÃ¨ges root.
Câ€™est pourquoi seuls certains programmes critiques ont ce bit activÃ©, et ils sont rigoureusement auditÃ©s.

Mot de passe de bandit20 : 0qXahG8ZjOVMN9Ghs7iOWsCfZyXOUbYO